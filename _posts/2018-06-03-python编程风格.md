---
title: python编程风格之好的代码逻辑
categories:
 - python
tags:
 - 编程风格
---
<blockquote>
  本文通过一个词频统计的代码，简单描述了python各种编程风格以及其特点，但风格无优劣，只是希望
希望读者能在项目中选择合适的编程风格。
</blockquote>     

## 引言
<blockquote>
  本文的介绍的项目很简单，给定一个文件，在去掉停用词之后，显示频率最高的N个词
</blockquote>

## 基本风格
### 1. 面条风格（瀑布风格）
特点：没有命名函数，没有对象，没有设计模式，拿起键盘直接干。
```python
#!/usr/bin/env python
import string

with open('../stop_words.txt') as f:
    stop_words = f.read().split(',')
stop_words.extend(list(string.ascii_lowercase))

word_count = {}
for line in open('../input.txt'):
    for word in line.split():
        if word not in stop_words:
            word_count.setdefault(word, 0)
            word_count[word] += 1

for tf in sorted(word_count.items(), key=lambda x: x[1], reverse=True):
    print tf[0], tf[1]
```
评价：从计算机诞生初期，该模式就已经兴起。写起来行云流水，一气呵成，外表看起来
波澜壮阔，内部有时却让人无从下手。虽然不被看好，但确延用至今，对于单一简单任务，
新手、老手都对它爱不释手。
### 2. 食谱风格
特点：使用过程抽象技术将一个大问题，拆解成若干小问题，并逐个解决，这些过程函数
使用全局变量的形式共享状态。
```python
#!/usr/bin/env python
# coding=utf-8
import string

data = []
word_freqs = []


def read_file(path_to_file):
    """
    读取文件单词
    :param path_to_file: 文件路径
    :return:
    """
    global data
    with open(path_to_file) as f:
        for word in f.readlines():
            data.extend(word.split(" "))


def filter_chars():
    """
    去掉空字符和换行符
    :return:
    """
    global data
    data = [d.strip() for d in data if d.strip()]


def remove_stop_words():
    """
    去掉停用词
    :return:
    """
    global data
    with open('../stop_words.txt') as f:
        stop_words = f.read().split(',')
    # add single-letter words
    stop_words.extend(list(string.ascii_lowercase))
    new_words = []
    for word in data:
        if word not in stop_words:
            new_words.append(word)
    data = new_words


def frequencies():
    """
    生成词频序列
    """
    global data
    global word_freqs
    word_count = {}
    for word in data:
        word_count.setdefault(word, 0)
        word_count[word] += 1
    word_freqs = word_count.items()


def sort():
    """
    词频排序
    """
    global word_freqs
    word_freqs.sort(lambda x, y: cmp(y[1], x[1]))


#
# The main function
#
read_file('../input.txt')
filter_chars()
remove_stop_words()
frequencies()
sort()

for tf in word_freqs[0:25]:
    print tf[0], ' - ', tf[1]
```
评价：每个过程函数独立处理一件事，结构化编程的第一步，通过数据共享为下一个过程函数提供数据，
就像是烹饪我们按照食谱进行每一步操作时，也会随着步骤的推进改变食材的状态。虽然数据共享会有一定的
风险，比如多放几次盐，食材的味道可能变的超出预期，但这就要取决利弊了。
### 3. 流水线风格（函数式编程）
特点：和食谱风格一样，但是这个函数间没有状态共享，函数根据输入形成输出。
```python
#!/usr/bin/env python
# coding=utf-8
import string


def read_file(path_to_file):
    """
    读取文件单词
    :param path_to_file: 文件路径
    :return []:
    """
    words = []
    with open(path_to_file) as f:
        for word in f.readlines():
            words.extend(word.split(" "))
    return words


def filter_chars(words):
    """
    去掉空字符和换行符
    :return:
    """
    return [d.strip() for d in words if d.strip()]


def remove_stop_words(words):
    """
    去掉停用词
    :return:
    """
    with open('../stop_words.txt') as f:
        stop_words = f.read().split(',')
    # add single-letter words
    stop_words.extend(list(string.ascii_lowercase))
    new_words = []
    for word in words:
        if word not in stop_words:
            new_words.append(word)
    return new_words


def frequencies(words):
    """
    生成词频序列
    """
    word_count = {}
    for word in words:
        word_count.setdefault(word, 0)
        word_count[word] += 1
    return word_count.items()


def sort(freq):
    """
    词频排序
    """
    freq.sort(lambda x, y: cmp(y[1], x[1]))
    return freq


#
# The main function
#
print(sort(frequencies(remove_stop_words(filter_chars(read_file('../input.txt'))))))
```
评价：和食谱风格既相似又不同，不同在于1、它不共享数据，2、(保持函数一致性)同函数多次调用输出结果都不变
它高度契合的数学的函数定义使它流传至今，如spark、mapreduce等等都对它进行了支持。
### 4. 极简风格
特点：多使用编程语言的高级特性和库来实现，让代码尽可能简洁
```python
#!/usr/bin/env python
import heapq, re, sys

words = re.findall("[a-z]{2,}", open('../input.txt').read().lower())
for w in heapq.nlargest(25, set(words) - set(open("../stop_words.txt").read().split(",")), words.count):
    print w, "-", words.count(w)
```
评价：运用得当，方可呼风唤雨，运用不当，小心走火入魔。
## 函数风格
### 1.递归风格
特点：使用数学归纳法将问题从0到n再到n+1推导
```python
#!/usr/bin/env python
import re, sys, operator


def count(word_list, stopwords, wordfreqs):
    if not word_list:
        return
    else:
        word = word_list[0]
        if word not in stopwords:
            if word in wordfreqs:
                wordfreqs[word] += 1
            else:
                wordfreqs[word] = 1
        count(word_list[1:], stopwords, wordfreqs)


def wf_print(wordfreq):
    if not wordfreq:
        return
    else:
        (w, c) = wordfreq[0]
        print w, '-', c
        wf_print(wordfreq[1:])


stop_words = set(open('../stop_words.txt').read().split(','))
words = re.findall('[a-z]{2,}', open('../input.txt').read().lower())
word_freqs = {}
CHUNK = 9500
for i in range(0, len(words), CHUNK):
    count(words[i:i+CHUNK], stop_words, word_freqs)

wf_print(sorted(word_freqs.iteritems(), key=operator.itemgetter(1), reverse=True)[:25])
```
评论：递归一时爽，堆栈火葬场，要想用的爽就需要有效减少递归的层数，或者像以上代码一样将数据
分块进行递归处理
### 2.callback风格
特点：每个函数都有一个额外的函数参数，并且在函数结束时调用该参数
```python
#!/usr/bin/env python
import sys, re, operator, string


def read_file(path_to_file, func):
    with open(path_to_file) as f:
        data = f.read()
    func(data, normalize)


def filter_chars(str_data, func):
    pattern = re.compile('[\W_]+')
    func(pattern.sub(' ', str_data), scan)


def normalize(str_data, func):
    func(str_data.lower(), remove_stop_words)


def scan(str_data, func):
    func(str_data.split(), frequencies)


def remove_stop_words(word_list, func):
    with open('../stop_words.txt') as f:
        stop_words = f.read().split(',')
    # add single-letter words
    stop_words.extend(list(string.ascii_lowercase))
    func([w for w in word_list if not w in stop_words], sort)


def frequencies(word_list, func):
    wf = {}
    for w in word_list:
        if w in wf:
            wf[w] += 1
        else:
            wf[w] = 1
    func(wf, print_text)


def sort(wf, func):
    func(sorted(wf.iteritems(), key=operator.itemgetter(1), reverse=True), no_op)


def print_text(word_freqs, func):
    for (w, c) in word_freqs[0:25]:
        print w, "-", c
    func(None)


def no_op(func):
    return


read_file('../input.txt', filter_chars)
```
评价：常用于真对程序的同状态执行不同操作，异步必会写法。但是你凝望着深渊，深渊也在凝望你，小心回调地狱。
### 3.真*流式风格
特点：需要一个可以修改数据的类，并将流水线风格的方法绑定在一起。
```python
#!/usr/bin/env python
import sys, re, operator, string


class TFTheOne:
    def __init__(self, v):
        self._value = v

    def bind(self, func):
        self._value = func(self._value)
        return self

    def printme(self):
        print self._value


def read_file(path_to_file):
    with open(path_to_file) as f:
        data = f.read()
    return data


def filter_chars(str_data):
    pattern = re.compile('[\W_]+')
    return pattern.sub(' ', str_data)


def normalize(str_data):
    return str_data.lower()


def scan(str_data):
    return str_data.split()


def remove_stop_words(word_list):
    with open('../stop_words.txt') as f:
        stop_words = f.read().split(',')
    # add single-letter words
    stop_words.extend(list(string.ascii_lowercase))
    return [w for w in word_list if not w in stop_words]


def frequencies(word_list):
    word_freqs = {}
    for w in word_list:
        if w in word_freqs:
            word_freqs[w] += 1
        else:
            word_freqs[w] = 1
    return word_freqs


def sort(word_freq):
    return sorted(word_freq.iteritems(), key=operator.itemgetter(1), reverse=True)


def top25_freqs(word_freqs):
    top25 = ""
    for tf in word_freqs[0:25]:
        top25 += str(tf[0]) + ' - ' + str(tf[1]) + '\n'
    return top25


TFTheOne(sys.argv[1]) \
    .bind(read_file) \
    .bind(filter_chars) \
    .bind(normalize) \
    .bind(scan) \
    .bind(remove_stop_words) \
    .bind(frequencies) \
    .bind(sort) \
    .bind(top25_freqs) \
    .printme()
```
特点：绑定方法返回自身，并且封装操作隔离了全局变量，绑定操作实现了隐式数据传递，
最后的拆分打开了封装。
## 面向对象风格
### 1.对象风格
### 2.消息风格
### 3.闭域风格
### 4.抽象对象风格
### 5.好莱坞风格
### 6.公告板风格
## 反射与元编程
## 异常处理
## 项目类型主导的基本风格
#### 以数据为中心
#### 并发
#### 交互